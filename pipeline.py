import ltl_utils

from tqdm import tqdm
from typing import List
from pprint import pprint

from features import BaseFeature
from features import PlayerLocFeature
from features import TeammateDensityFeature
from features import OpponentsDensityFeature
from features import HasBallFeature
from features import CanPassToFeature
from features import ProgressivePassingLane
from features import BackwardPassingLane
from features import OpponentPressureFeature

from utils import GameLoader
from utils import PlayerTracker
from utils import AllTracker

from separations import team_possession_separation



class Pipeline:
    def __init__(self, data_base_path: str, game_name: str, player_jersey_number: int, home: bool=True):
        # loding the game
        self.game = GameLoader(data_base_path, game_name)

        # loading the player tracker
        self.player_tracker = PlayerTracker(self.game, player_jersey_number, home)
        # loading all players/ball tracker
        self.all_tracker = AllTracker(self.game)
        
        # filling the tracking information
        self.player_tracker.track()
        self.all_tracker.track()
        
        self.feature_makers = []
        self.proposition_traces = []
        
    def add_features(self, features: List[BaseFeature]) -> None:
        """
        This function receives a list of features all of which are subclasses of
        the BaseFeature class and implement generate() and translate() methods.
        The function adds the features to the self.feature_maker list.
        
        :param features (List[BaseFeature]): a list of features
        """
        for feature in features:
            # check if the given feature is a subclass of BaseFeature
            if issubclass(feature.__class__, BaseFeature):
                self.feature_makers.append(feature)
            else:
                raise Exception(f'[!] Expected a feature subclass of BaseFeature, received {feature.__class__} instead!')
    
    def make_propositions(self, on_ball_possession=False) -> None:
        """
        This function calls the features in the self.feature_makers one by one
        and invokes their generate and translate methods to extract the propositions.
        However, the extracted propositions are not in the correct order and they should
        be reorganized; i.e., initially the trace will contain all the elements of the
        first feature, all the elements of the second feature, and so on, while we need
        the trace to contain first element of all features, second element of all features
        and so on.
        """
        # check of the feature makers list is empty
        if len(self.feature_makers) == 0:
            raise Exception('[!] There are no features available! Try adding some features first.')
        
        trace_element = []
        # invoke the generate() and traslate() methods of each feature to generate the
        # propositions.
        for feature_maker in self.feature_makers:
            feature_maker.generate(on_ball_possession)
            trace_element.append(feature_maker.translate())
        
        # reorganize the trace and add it to the proposition traces
        print('[*] Generating and reorganzing the trace...')
        self.proposition_traces = self.reorganize(trace_element)
        
        self.pos_traces, self.neg_traces = team_possession_separation(self.proposition_traces, self.game, self.player_tracker)
    
    def reorganize(self, feature_list: List[List]) -> List[List]:
        """
        This function receives the unordered traces generated by the make_propositions
        function and reorganizes the traces to their correct ordering as explained in
        the make_proposition function.
        
        :param feature_list (List[List]): a list containing the traces of each feature;
                                          i.e., the fist element is a list containing the
                                          traces of the first feature, and so on.
        """
        # get the number of features
        num_features = len(feature_list)
        
        # get the length of the traces
        trace_num_elements = min([len(feature_list[i]) for i in range(num_features)])
        
        # store the reorganzied trace
        reorganized_trace = []
        
        # reordering the trace elements to the correct form
        for index in tqdm(range(trace_num_elements)):
            reorganized_element = []
            for feature_index in range(num_features):
                reorganized_element.append(feature_list[feature_index][index])

            reorganized_trace.append([reorganized_element])
        
        return reorganized_trace

    def make_inference(self):
        print('[*] Extracting the LTL formula...')
        print(len(self.pos_traces[10]), len(self.neg_traces[10]))
        contrastive_explanations = ltl_utils.bayesLtlExplanationsList(self.pos_traces[10], self.neg_traces[10], 10)
        
        pprint(contrastive_explanations)
        
        example_trace = self.proposition_traces[110]
        example_formula = contrastive_explanations[0][0]

        print('\nExample trace:\n' + str(example_trace)[:162] + '\n')
        print('\nExample Formula:\n' + example_formula + '\n')


        print('Trace entails formula? => ' + str(ltl_utils.doesTraceEntailFormula(example_formula, example_trace)))


if __name__ == '__main__':
    base_path = 'all_Games'
    game_name = 'AIK__BK HÃ¤cken.1'
    jersey_number = 4
    home = True
    
    # constructing the pipeline
    pipeline = Pipeline(base_path, game_name, jersey_number, home)

    # constructing the 
    feat1 = PlayerLocFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat2 = TeammateDensityFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat3 = OpponentsDensityFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat4 = HasBallFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat5 = CanPassToFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat6 = ProgressivePassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='low')
    feat7 = ProgressivePassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='medium')
    feat8 = ProgressivePassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='high')
    feat9 = BackwardPassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='low')
    feat10 = BackwardPassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='medium')
    feat11 = BackwardPassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='high')
    feat12 = OpponentPressureFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    
    features = [feat1, feat2, feat3, feat4, feat5, feat6, feat7, feat8, feat9, feat10, feat11, feat12]
    
    pipeline.add_features(features)
    pipeline.make_propositions(on_ball_possession=False)
    # pprint(pipeline.proposition_traces[100: 200])
    # pprint(pipeline.proposition_traces[1000: 1100])
    pipeline.make_inference()
    
    
