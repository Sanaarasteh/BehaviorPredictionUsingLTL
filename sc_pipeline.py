import ltl_utils

from tqdm import tqdm
from typing import List
from pprint import pprint

from sc_features import BaseFeature
from sc_features import PlayerLocFeature
from sc_features import PlayerLoc2Feature
from sc_features import TeammateDensityFeature
from sc_features import OpponentsDensityFeature
from sc_features import HasBallFeature
from sc_features import CanPassToFeature
from sc_features import ProgressivePassingLane
from sc_features import BackwardPassingLane
from sc_features import OpponentPressureFeature
from sc_features import VelocityFeature
from sc_features import ExpansionContractionFeature
from sc_features import PositionSpectralFeature

from sc_utils import GameLoader
from sc_utils import PlayerTracker
from sc_utils import AllTracker
from sc_utils import Visualizers

from sc_separations import team_possession_separation
from sc_separations import attack_defense_separation
from sc_separations import passing_style_separation



class Pipeline:
    def __init__(self, data_base_path: str, game_name: str, first_name: str, last_name: str, home: bool=True):
        # loding the game
        self.game = GameLoader(data_base_path, game_name)
        # loading the player tracker
        self.player_tracker = PlayerTracker(self.game, first_name, last_name, home)
        # loading all players/ball tracker
        self.all_tracker = AllTracker(self.game)
        
        # filling the tracking information
        self.player_tracker.track()
        self.all_tracker.track()
        
        self.feature_makers = []
        self.proposition_traces = []
        
    def add_features(self, features: List[BaseFeature]) -> None:
        """
        This function receives a list of features all of which are subclasses of
        the BaseFeature class and implement generate() and translate() methods.
        The function adds the features to the self.feature_maker list.
        
        :param features (List[BaseFeature]): a list of features
        """
        for feature in features:
            # check if the given feature is a subclass of BaseFeature
            if issubclass(feature.__class__, BaseFeature):
                self.feature_makers.append(feature)
            else:
                raise Exception(f'[!] Expected a feature subclass of BaseFeature, received {feature.__class__} instead!')
    
    def make_propositions(self, on_ball_possession=False) -> None:
        """
        This function calls the features in the self.feature_makers one by one
        and invokes their generate and translate methods to extract the propositions.
        However, the extracted propositions are not in the correct order and they should
        be reorganized; i.e., initially the trace will contain all the elements of the
        first feature, all the elements of the second feature, and so on, while we need
        the trace to contain first element of all features, second element of all features
        and so on.
        """
        # check of the feature makers list is empty
        if len(self.feature_makers) == 0:
            raise Exception('[!] There are no features available! Try adding some features first.')
        
        trace_element = []
        # invoke the generate() and traslate() methods of each feature to generate the
        # propositions.
        for feature_maker in self.feature_makers:
            feature_maker.generate(on_ball_possession)
            trace_element.append(feature_maker.translate())
        
        # reorganize the trace and add it to the proposition traces
        print('[*] Generating and reorganzing the trace...')
        self.proposition_traces = self.reorganize(trace_element)
        
        # self.pos_traces, self.neg_traces = team_possession_separation(self.proposition_traces, self.game, self.player_tracker)
        # self.pos_traces, self.neg_traces = attack_defense_separation(self.proposition_traces, self.game, self.all_tracker, 
        #                                                              self.player_tracker, attack_mode='penetration', defense_mode='retreat')
        self.pos_traces, self.neg_traces = passing_style_separation(self.proposition_traces, self.game, self.player_tracker, self.all_tracker)
        print(len(self.pos_traces), len(self.neg_traces))
           
    def reorganize(self, feature_list: List[List]) -> List[List]:
        """
        This function receives the unordered traces generated by the make_propositions
        function and reorganizes the traces to their correct ordering as explained in
        the make_proposition function.
        
        :param feature_list (List[List]): a list containing the traces of each feature;
                                          i.e., the fist element is a list containing the
                                          traces of the first feature, and so on.
        """
        # get the number of features
        num_features = len(feature_list)
        
        # get the length of the traces
        trace_num_elements = min([len(feature_list[i]) for i in range(num_features)])
        
        # store the reorganzied trace
        reorganized_trace = []
        
        # reordering the trace elements to the correct form
        for index in tqdm(range(trace_num_elements)):
            reorganized_element = []
            for feature_index in range(num_features):
                reorganized_element.append(feature_list[feature_index][index])

            reorganized_trace.append([reorganized_element])
        
        return reorganized_trace

    def make_inference(self):
        print('[*] Extracting the LTL formula...')
        
        contrastive_explanations = ltl_utils.bayesLtlExplanationsList(self.pos_traces[:3000], self.neg_traces[:3000], 30)
        self.formulas = contrastive_explanations
        
        pprint(contrastive_explanations)
        
        example_trace = self.proposition_traces[110]
        example_formula = contrastive_explanations[0][0]

        print('\nExample trace:\n' + str(example_trace) + '\n')
        print('\nExample Formula:\n' + example_formula + '\n')

        print('Trace entails formula? => ' + str(ltl_utils.doesTraceEntailFormula(example_formula, example_trace)))
        
        return self.formulas

    def visualize_formula(self):
        visualizer = Visualizers(self.game, self.player_tracker, self.all_tracker)
        print('[*] Saving the visualization of the formulas...')
        visualizer.visualize_formulas(self.proposition_traces, self.formulas)


if __name__ == '__main__':
    base_path = 'data/matches'
    game_name = '852654-Manchester City-Chelsea'
    first_name = 'Kevin'
    last_name = 'De Bruyne'
    home = True
    
    # constructing the pipeline
    pipeline = Pipeline(base_path, game_name, first_name, last_name, home)

    # constructing the 
    feat1 = PlayerLocFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat2 = TeammateDensityFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat3 = OpponentsDensityFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat4 = HasBallFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat5 = CanPassToFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat6 = ProgressivePassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='low')
    feat7 = ProgressivePassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='medium')
    feat8 = ProgressivePassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='high')
    feat9 = BackwardPassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='low')
    feat10 = BackwardPassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='medium')
    feat11 = BackwardPassingLane(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, threshold='high')
    feat12 = OpponentPressureFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat13 = VelocityFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, interval=20)
    feat14 = ExpansionContractionFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, interval=20, k=3)
    feat15 = PlayerLoc2Feature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker)
    feat16 = PositionSpectralFeature(pipeline.game, pipeline.player_tracker, pipeline.all_tracker, interval=20)
    
    features = [feat1, feat2, feat3, feat4, feat5, feat6, 
                feat7, feat8, feat9, feat10, feat11, feat12,
                feat13, feat14, feat15, feat16]
    
    pipeline.add_features(features)
    pipeline.make_propositions(on_ball_possession=False)
    # pprint(pipeline.proposition_traces[100: 200])
    # pprint(pipeline.proposition_traces[1000: 1100])
    pipeline.make_inference()
    # pipeline.visualize_formula()
    
    
